<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snake – Mini Games Arcade</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #38bdf8;
      --danger: #f97316;
      --good: #22c55e;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    html, body {
      height: 100%;
    }

    body {
      min-height: 100vh;
      overflow: hidden;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%);
      color: var(--text);
      display: flex;
      justify-content: center;
      padding: 10px;
    }

    .page {
      width: 100%;
      max-width: 1200px;
      display: grid;
      grid-template-columns: 200px minmax(0, 1fr) 200px;
      gap: 10px;
      align-items: center;
    }

    @media (max-width: 960px) {
      body {
        overflow-y: auto;
      }
      .page {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .panel {
      background: radial-gradient(circle at top, #020617 0, #020617 70%);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.7);
      padding: 10px;
    }

    .ad-column {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .ad-slot {
      height: 140px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 14px;
      border: 2px dashed rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.8);
      color: var(--muted);
      text-align: center;
      padding: 6px;
      font-size: 0.78rem;
    }

    .ad-label {
      font-weight: 600;
      margin-bottom: 2px;
    }

    .ad-size {
      font-size: 0.75rem;
      opacity: 0.9;
      margin-bottom: 2px;
    }

    .main-panel {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
    }

    .top-bar {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
    }

    .back-link {
      text-decoration: none;
      font-size: 0.78rem;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.8);
    }

    .back-link:hover {
      border-color: var(--accent);
      color: #f9fafb;
    }

    h1 {
      font-size: 1.7rem;
      letter-spacing: 0.06em;
    }

    .subtitle {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 4px;
      width: 100%;
    }

    .game-container {
      width: 100%;
      max-width: 480px;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      flex-wrap: wrap;
    }

    .score-boxes {
      display: flex;
      gap: 6px;
    }

    .score-box {
      min-width: 70px;
      padding: 4px 8px 3px;
      border-radius: 8px;
      background: radial-gradient(circle at top, #1f2937 0, #020617 70%);
      color: var(--text);
      text-align: center;
      border: 1px solid rgba(148, 163, 184, 0.7);
    }

    .score-label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.9;
      color: var(--muted);
    }

    .score-value {
      font-size: 1rem;
      font-weight: 700;
      margin-top: 1px;
    }

    .btn {
      border: none;
      outline: none;
      padding: 5px 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, #38bdf8, #1d4ed8);
      color: #f9fafb;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.78rem;
      box-shadow: 0 5px 14px rgba(37, 99, 235, 0.6);
      transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.15s;
      white-space: nowrap;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(37, 99, 235, 0.8);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(37, 99, 235, 0.5);
    }

    .controls-text {
      font-size: 0.78rem;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .controls-text span {
      background: rgba(15, 23, 42, 0.85);
      border-radius: 999px;
      padding: 2px 7px;
      margin-right: 4px;
      border: 1px solid rgba(148, 163, 184, 0.6);
    }

    .board-wrapper {
      width: 100%;
      max-width: 380px;
      margin: 0 auto;
      aspect-ratio: 1 / 1;
      background: radial-gradient(circle at top, #020617 0, #000000 75%);
      border-radius: 10px;
      padding: 6px;
      box-shadow: 0 14px 0 #020617, 0 20px 32px rgba(0, 0, 0, 0.85);
      position: relative;
      overflow: hidden;
      user-select: none;
      touch-action: none;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 8px;
      background: #020617;
    }

    .status-row {
      margin-top: 4px;
      font-size: 0.78rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 6px;
    }

    .status-text {
      font-weight: 600;
    }

    .status-text.over {
      color: var(--danger);
    }

    .status-text.good {
      color: var(--good);
    }
  </style>
</head>
<body>
  <div class="page">
    <!-- Left ads -->
    <aside class="panel ad-column">
      <div class="ad-slot">
        <div class="ad-label">Ad Slot #1</div>
        <div class="ad-size">300 × 250</div>
        <div>Paste banner/ad script here.</div>
      </div>
      <div class="ad-slot">
        <div class="ad-label">Ad Slot #2</div>
        <div class="ad-size">160 × 600</div>
      </div>
    </aside>

    <!-- Game -->
    <main class="panel main-panel">
      <div class="top-bar">
        <a class="back-link" href="index.html">← Back to games</a>
        <h1>Snake</h1>
      </div>
      <p class="subtitle">
        Guide the snake, eat food, avoid walls and yourself.
      </p>

      <div class="game-container">
        <div class="info-row">
          <div class="score-boxes">
            <div class="score-box">
              <div class="score-label">Score</div>
              <div id="score" class="score-value">0</div>
            </div>
            <div class="score-box">
              <div class="score-label">Best</div>
              <div id="best" class="score-value">0</div>
            </div>
            <div class="score-box">
              <div class="score-label">Speed</div>
              <div id="speed" class="score-value">1x</div>
            </div>
          </div>
          <button id="newGameBtn" class="btn">New Game</button>
        </div>

        <div class="controls-text">
          <span>↑ ↓ ← → / WASD: Move</span>
          <span>Mobile: swipe on the board</span>
        </div>

        <div class="board-wrapper" id="boardWrapper">
          <canvas id="gameCanvas" width="400" height="400"></canvas>
        </div>

        <div class="board-wrapper" id="boardWrapper">

        <div class="status-row">
          <span id="statusText" class="status-text"></span>
          <span>Tip: plan turns early, not last second.</span>
        </div>
      </div>
    </main>

    <!-- Right ads -->
    <aside class="panel ad-column">
      <div class="ad-slot">
        <div class="ad-label">Ad Slot #3</div>
        <div class="ad-size">300 × 250</div>
      </div>
      <div class="ad-slot">
        <div class="ad-label">Ad Slot #4</div>
        <div class="ad-size">Flexible</div>
      </div>
    </aside>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const bestEl = document.getElementById("best");
      const speedEl = document.getElementById("speed");
      const statusText = document.getElementById("statusText");
      const newGameBtn = document.getElementById("newGameBtn");
      const boardWrapper = document.getElementById("boardWrapper");

      const GRID_SIZE = 20; // 20x20
      const CELL = canvas.width / GRID_SIZE;
      const BEST_KEY = "arcadeSnakeBest";

      let snake = [];
      let direction = { x: 1, y: 0 };      // actual movement direction (updated at each tick)
      let nextDirection = { x: 1, y: 0 };  // queued direction from inputs
      let food = null;
      let score = 0;
      let best = Number(localStorage.getItem(BEST_KEY)) || 0;
      let speedLevel = 1;
      let tickInterval = 110;              // faster = smoother
      let timer = null;
      let gameOver = false;

      bestEl.textContent = best;

      function resetGame() {
        snake = [
          { x: 8, y: 10 },
          { x: 7, y: 10 },
          { x: 6, y: 10 },
        ];
        direction = { x: 1, y: 0 };
        nextDirection = { x: 1, y: 0 };
        score = 0;
        speedLevel = 1;
        tickInterval = 110;
        scoreEl.textContent = "0";
        speedEl.textContent = speedLevel + "x";
        statusText.textContent = "";
        statusText.className = "status-text";
        gameOver = false;

        placeFood();
        restartLoop();
        draw();
      }

      function placeFood() {
        let valid = false;
        while (!valid) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (!snake.some(seg => seg.x === x && seg.y === y)) {
            food = { x, y };
            valid = true;
          }
        }
      }

      function restartLoop() {
        if (timer) clearInterval(timer);
        timer = setInterval(tick, tickInterval);
      }

      function tick() {
        if (gameOver) return;

        // Apply queued direction change at start of tick
        direction = { ...nextDirection };

        const head = snake[0];
        const newHead = {
          x: head.x + direction.x,
          y: head.y + direction.y,
        };

        // wall collision
        if (
          newHead.x < 0 ||
          newHead.x >= GRID_SIZE ||
          newHead.y < 0 ||
          newHead.y >= GRID_SIZE
        ) {
          return endGame();
        }

        // self collision
        if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
          return endGame();
        }

        // move snake
        snake.unshift(newHead);

        // food?
        if (food && newHead.x === food.x && newHead.y === food.y) {
          score += 10;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
            localStorage.setItem(BEST_KEY, best);
          }
          // Smooth speed increase: every 50 points
          if (score % 50 === 0 && tickInterval > 70) {
            speedLevel++;
            tickInterval -= 8; // small change so it feels smoother
            speedEl.textContent = speedLevel + "x";
            restartLoop();
            statusText.textContent = "Speed up!";
            statusText.className = "status-text good";
            setTimeout(() => {
              if (!gameOver) {
                statusText.textContent = "";
                statusText.className = "status-text";
              }
            }, 600);
          }
          placeFood();
        } else {
          // remove tail
          snake.pop();
        }

        draw();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // background
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // subtle grid
        ctx.strokeStyle = "#0b1220";
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_SIZE; i++) {
          const p = i * CELL;
          ctx.beginPath();
          ctx.moveTo(p, 0);
          ctx.lineTo(p, canvas.height);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, p);
          ctx.lineTo(canvas.width, p);
          ctx.stroke();
        }

        // food: glowing orb
        if (food) {
          const fx = food.x * CELL;
          const fy = food.y * CELL;
          const cx = fx + CELL / 2;
          const cy = fy + CELL / 2;
          const r = CELL / 2.4;
          const grad = ctx.createRadialGradient(cx, cy, r / 4, cx, cy, r);
          grad.addColorStop(0, "#facc15");
          grad.addColorStop(1, "#f97316");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
        }

        // snake body
        snake.forEach((seg, idx) => {
          const x = seg.x * CELL;
          const y = seg.y * CELL;

          if (idx === 0) {
            // head with gradient + eyes
            const grad = ctx.createLinearGradient(x, y, x + CELL, y + CELL);
            grad.addColorStop(0, "#38bdf8");
            grad.addColorStop(1, "#1d4ed8");
            ctx.fillStyle = grad;
            roundRect(ctx, x + 1, y + 1, CELL - 2, CELL - 2, CELL * 0.25);
            ctx.fill();

            // eyes based on direction
            const eyeOffset = CELL * 0.18;
            const eyeRadius = CELL * 0.09;
            let ex1 = x + CELL / 2;
            let ey1 = y + CELL / 2;
            let ex2 = ex1;
            let ey2 = ey1;

            if (direction.x === 1) { // right
              ex1 = x + CELL * 0.6;
              ex2 = x + CELL * 0.6;
              ey1 = y + CELL * 0.35;
              ey2 = y + CELL * 0.65;
            } else if (direction.x === -1) { // left
              ex1 = x + CELL * 0.4;
              ex2 = x + CELL * 0.4;
              ey1 = y + CELL * 0.35;
              ey2 = y + CELL * 0.65;
            } else if (direction.y === -1) { // up
              ey1 = y + CELL * 0.4;
              ey2 = y + CELL * 0.4;
              ex1 = x + CELL * 0.35;
              ex2 = x + CELL * 0.65;
            } else if (direction.y === 1) { // down
              ey1 = y + CELL * 0.6;
              ey2 = y + CELL * 0.6;
              ex1 = x + CELL * 0.35;
              ex2 = x + CELL * 0.65;
            }

            ctx.fillStyle = "#0b1120";
            ctx.beginPath(); ctx.arc(ex1, ey1, eyeRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(ex2, ey2, eyeRadius, 0, Math.PI * 2); ctx.fill();
          } else {
            // body: slightly rounded rects
            const bodyGrad = ctx.createLinearGradient(x, y, x + CELL, y + CELL);
            bodyGrad.addColorStop(0, "#22c55e");
            bodyGrad.addColorStop(1, "#16a34a");
            ctx.fillStyle = bodyGrad;
            roundRect(ctx, x + 1.5, y + 1.5, CELL - 3, CELL - 3, CELL * 0.22);
            ctx.fill();
          }
        });
      }

      function roundRect(ctx, x, y, w, h, r) {
        const radius = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + w - radius, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
        ctx.lineTo(x + w, y + h - radius);
        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
        ctx.lineTo(x + radius, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
      }

      function endGame() {
        gameOver = true;
        if (timer) clearInterval(timer);
        statusText.textContent = "Game over – press New Game to try again.";
        statusText.className = "status-text over";
      }

      function handleDirectionChange(dx, dy) {
        // Prevent reversing relative to the *queued* direction,
        // so you can't spam two keys and flip back on the same tick.
        if (dx === -nextDirection.x && dy === -nextDirection.y) return;
        nextDirection = { x: dx, y: dy };
      }

      // keyboard controls
      window.addEventListener("keydown", (e) => {
        const k = e.key;
        if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","a","A","d","D","w","W","s","S"].includes(k)) {
          e.preventDefault();
        }
        if (k === "ArrowLeft" || k === "a" || k === "A") {
          handleDirectionChange(-1, 0);
        } else if (k === "ArrowRight" || k === "d" || k === "D") {
          handleDirectionChange(1, 0);
        } else if (k === "ArrowUp" || k === "w" || k === "W") {
          handleDirectionChange(0, -1);
        } else if (k === "ArrowDown" || k === "s" || k === "S") {
          handleDirectionChange(0, 1);
        }
      });

      // swipe controls for mobile
      let touchStartX = 0;
      let touchStartY = 0;
      let touching = false;

      boardWrapper.addEventListener("touchstart", (e) => {
        if (e.touches.length !== 1) return;
        const t = e.touches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touching = true;
      });

      boardWrapper.addEventListener("touchmove", (e) => {
        if (!touching) return;
        e.preventDefault();
      }, { passive: false });

      boardWrapper.addEventListener("touchend", (e) => {
        if (!touching) return;
        touching = false;
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        const threshold = 20;
        if (absX < threshold && absY < threshold) return;
        if (absX > absY) {
          if (dx > 0) handleDirectionChange(1, 0);
          else handleDirectionChange(-1, 0);
        } else {
          if (dy > 0) handleDirectionChange(0, 1);
          else handleDirectionChange(0, -1);
        }
      });

      newGameBtn.addEventListener("click", resetGame);

      // start game
      resetGame();
    })();
  </script>
</body>
</html>
