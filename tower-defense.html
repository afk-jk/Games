<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="UTF-8" />
  <title>Path Defender V2 â€“ Mini Games Arcade</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  
  <!-- Google AdSense -->
  <script async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1522584826215697"
    crossorigin="anonymous"></script>
  
  <style>
    :root {
      --panel-bg: rgba(15, 23, 42, 0.95);
      --border: rgba(148, 163, 184, 0.7);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #38bdf8;
      --danger: #f97316;
      --good: #22c55e;
      --gold: #facc15;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #4b5563, #020617 60%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 10px;
      overflow-y: auto;
      color: var(--text);
    }

    .wrapper {
      width: 100%;
      max-width: 980px;
      display: grid;
      grid-template-columns: minmax(0, 2.1fr) 250px;
      gap: 10px;
    }

    @media (max-width: 900px) {
      .wrapper {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .panel {
      background: var(--panel-bg);
      border-radius: 14px;
      border: 1px solid var(--border);
      box-shadow: 0 10px 30px rgba(0,0,0,0.8);
      padding: 10px;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
    }

    .stats {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      font-size: 0.82rem;
    }

    .pill {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.9);
    }

    .pill.gold {
      color: var(--gold);
      border-color: var(--gold);
    }

    .btn {
      padding: 4px 10px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #38bdf8, #1d4ed8);
      color: #f9fafb;
      font-weight: 600;
      font-size: 0.8rem;
      cursor: pointer;
      box-shadow: 0 6px 14px rgba(37,99,235,0.7);
      white-space: nowrap;
      transition: 0.12s;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 9px 20px rgba(37,99,235,0.9);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(15,23,42,0.9);
    }

    .btn.secondary {
      background: rgba(15,23,42,0.95);
      box-shadow: none;
      border: 1px solid var(--border);
    }

    .hint {
      font-size: 0.78rem;
      color: var(--muted);
      margin-bottom: 6px;
      line-height: 1.4;
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
      background: #020617;
      border-radius: 12px;
    }

    /* SIDE PANEL */

    .side-title {
      font-size: 0.96rem;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .side-section {
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(30, 64, 175, 0.7);
    }

    .tower-buttons {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .tower-btn {
      width: 100%;
      text-align: left;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.98);
      padding: 5px 8px;
      font-size: 0.78rem;
      color: var(--text);
      cursor: pointer;
    }

    .tower-btn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.7);
    }

    .tower-btn-title {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 6px;
      margin-bottom: 2px;
    }

    .tower-btn-name {
      font-weight: 600;
    }

    .tower-btn-cost {
      color: var(--gold);
      font-size: 0.75rem;
    }

    .tower-btn-desc {
      color: var(--muted);
      font-size: 0.72rem;
    }

    .status-text {
      font-size: 0.75rem;
      color: var(--muted);
      min-height: 1.2em;
      margin-top: 4px;
    }

    .tower-info {
      font-size: 0.78rem;
      line-height: 1.35;
    }

    .tower-info-row {
      margin-bottom: 2px;
    }

    .tower-info .no-selection {
      color: var(--muted);
    }

    .upgrade-btn {
      margin-top: 5px;
      width: 100%;
      text-align: center;
    }

    .tag {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      font-size: 0.7rem;
      color: var(--muted);
      margin-left: 4px;
    }

    .tag.air {
      border-color: #38bdf8;
      color: #bae6fd;
    }

    .tag.support {
      border-color: #22c55e;
      color: #bbf7d0;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <!-- MAIN GAME PANEL -->
    <div class="panel">
      <div class="top-bar">
        <div class="stats">
          <span class="pill">Wave: <span id="wave">1</span></span>
          <span class="pill">Lives: <span id="lives">20</span></span>
          <span class="pill gold">Gold: <span id="gold">150</span> ðŸª™</span>
          <span class="pill">Enemies: <span id="enemiesCount">0</span></span>
        </div>
        <button class="btn" id="startWaveBtn">Start Wave</button>
      </div>

      <div class="hint">
        <strong>How to play:</strong> Pick a tower on the right, then click on the map to place it.
        Towers attack enemies in their range. Click a tower to see its stats and upgrade it.
      </div>

      <canvas id="gameCanvas" width="640" height="384"></canvas>
    </div>

    <!-- SIDE PANEL -->
    <aside class="panel">
      <div class="side-section">
        <div class="side-title">Build Towers</div>
        <div class="tower-buttons" id="towerButtons">
          <!-- Buttons are created in JS for easier syncing -->
        </div>
        <div class="status-text" id="buildStatusText">
          Select a tower type, then click on the map to place it.
        </div>
      </div>

      <div class="side-section">
        <div class="side-title">Selected Tower</div>
        <div class="tower-info" id="towerInfo">
          <div class="no-selection">
            No tower selected. Click a tower on the map.
          </div>
        </div>
        <button class="btn upgrade-btn" id="upgradeTowerBtn" disabled>
          Upgrade Tower
        </button>
      </div>

      <div>
        <div class="side-title">Tips</div>
        <div class="tower-info">
          <div class="tower-info-row">
            â€¢ Put <strong>Splash</strong> and <strong>Frost</strong> near spots where multiple paths are close.
          </div>
          <div class="tower-info-row">
            â€¢ Use <strong>Air Towers</strong> to stop flying enemies that ignore the maze.
          </div>
          <div class="tower-info-row">
            â€¢ <strong>Support Towers</strong> buff nearby towers â€“ stack them smartly.
          </div>
        </div>
      </div>
    </aside>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      const waveEl = document.getElementById("wave");
      const livesEl = document.getElementById("lives");
      const goldEl = document.getElementById("gold");
      const enemiesCountEl = document.getElementById("enemiesCount");
      const startWaveBtn = document.getElementById("startWaveBtn");
      const buildStatusText = document.getElementById("buildStatusText");
      const towerInfoEl = document.getElementById("towerInfo");
      const upgradeTowerBtn = document.getElementById("upgradeTowerBtn");
      const towerButtonsContainer = document.getElementById("towerButtons");

      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;

      // GAME STATE
      let lives = 20;
      let gold = 150;
      let waveNumber = 1;
      let enemies = [];
      let towers = [];
      let bullets = [];
      let running = true;
      let lastTime = performance.now();

      let spawnTimer = 0;
      let enemiesToSpawn = 0;
      let waveInProgress = false;

      let selectedTower = null;
      let buildMode = null; // tower key or null

      // 3 Maze-like paths (cartoony)
      // left side spawns, right side exit
      const paths = [
        // Top path (A)
        [
          { x: -20, y: 70 },
          { x: 150, y: 70 },
          { x: 150, y: 140 },
          { x: 300, y: 140 },
          { x: 300, y: 80 },
          { x: 480, y: 80 },
          { x: 640 + 20, y: 80 }
        ],
        // Middle path (B)
        [
          { x: -20, y: 190 },
          { x: 110, y: 190 },
          { x: 110, y: 260 },
          { x: 270, y: 260 },
          { x: 270, y: 200 },
          { x: 440, y: 200 },
          { x: 440, y: 260 },
          { x: 640 + 20, y: 260 }
        ],
        // Bottom path (C)
        [
          { x: -20, y: 320 },
          { x: 180, y: 320 },
          { x: 180, y: 240 },
          { x: 340, y: 240 },
          { x: 340, y: 320 },
          { x: 520, y: 320 },
          { x: 640 + 20, y: 320 }
        ]
      ];

      // ENEMY TYPES (base stats â€“ will be scaled per wave)
      const enemyBaseTypes = {
        grunt: {
          name: "Grunt",
          baseHp: 45,
          baseSpeed: 37,
          reward: 8,
          color: "#22c55e",
          radius: 10,
          shielded: false,
          flying: false,
          healer: false,
          boss: false
        },
        fast: {
          name: "Runner",
          baseHp: 35,
          baseSpeed: 65,
          reward: 10,
          color: "#a855f7",
          radius: 9,
          shielded: false,
          flying: false,
          healer: false,
          boss: false
        },
        tank: {
          name: "Tank",
          baseHp: 110,
          baseSpeed: 30,
          reward: 18,
          color: "#38bdf8",
          radius: 13,
          shielded: false,
          flying: false,
          healer: false,
          boss: false
        },
        shielded: {
          name: "Shielded",
          baseHp: 90,
          baseSpeed: 35,
          reward: 16,
          color: "#f97316",
          radius: 11,
          shielded: true,
          flying: false,
          healer: false,
          boss: false
        },
        healer: {
          name: "Healer",
          baseHp: 70,
          baseSpeed: 40,
          reward: 20,
          color: "#facc15",
          radius: 11,
          shielded: false,
          flying: false,
          healer: true,
          boss: false
        },
        flyer: {
          name: "Flyer",
          baseHp: 55,
          baseSpeed: 75,
          reward: 15,
          color: "#e5e7eb",
          radius: 10,
          shielded: false,
          flying: true,
          healer: false,
          boss: false
        },
        boss: {
          name: "Boss",
          baseHp: 600,
          baseSpeed: 32,
          reward: 80,
          color: "#ef4444",
          radius: 20,
          shielded: true,
          flying: false,
          healer: false,
          boss: true
        }
      };

      // TOWER DEFINITIONS
      const towerDefs = [
        {
          key: "basic",
          name: "Basic Cannon",
          cost: 50,
          baseDamage: 16,
          baseRange: 90,
          baseFireRate: 1.2,
          bulletSpeed: 260,
          color: "#e5e7eb",
          canHitAir: true,
          type: "projectile",
          tags: []
        },
        {
          key: "sniper",
          name: "Sniper Tower",
          cost: 90,
          baseDamage: 45,
          baseRange: 180,
          baseFireRate: 0.6,
          bulletSpeed: 420,
          color: "#38bdf8",
          canHitAir: true,
          type: "projectile",
          tags: []
        },
        {
          key: "splash",
          name: "Splash Cannon",
          cost: 80,
          baseDamage: 14,
          baseRange: 100,
          baseFireRate: 0.9,
          bulletSpeed: 220,
          splashRadius: 40,
          color: "#f97316",
          canHitAir: false,
          type: "splash",
          tags: []
        },
        {
          key: "frost",
          name: "Frost Tower",
          cost: 75,
          baseDamage: 8,
          baseRange: 100,
          baseFireRate: 1.1,
          bulletSpeed: 230,
          slowAmount: 0.4, // 40% slow
          slowDuration: 2.5,
          color: "#60a5fa",
          canHitAir: false,
          type: "slow",
          tags: []
        },
        {
          key: "laser",
          name: "Laser Tower",
          cost: 110,
          baseDamage: 30, // per second
          baseRange: 120,
          baseFireRate: 0, // continuous
          color: "#a855f7",
          canHitAir: true,
          type: "laser",
          tags: []
        },
        {
          key: "poison",
          name: "Poison Tower",
          cost: 85,
          baseDamage: 6,
          baseRange: 100,
          baseFireRate: 1.6,
          bulletSpeed: 240,
          dotDamage: 3,
          dotDuration: 4,
          color: "#22c55e",
          canHitAir: false,
          type: "poison",
          tags: []
        },
        {
          key: "support",
          name: "Support Tower",
          cost: 70,
          baseDamage: 0,
          baseRange: 110,
          baseFireRate: 0,
          color: "#facc15",
          canHitAir: false,
          type: "support",
          tags: ["support"]
        },
        {
          key: "air",
          name: "Air Tower",
          cost: 75,
          baseDamage: 15,
          baseRange: 120,
          baseFireRate: 1.5,
          bulletSpeed: 260,
          color: "#0ea5e9",
          canHitAir: true,
          type: "projectile",
          tags: ["air"]
        }
      ];

      // Build tower buttons dynamically
      const towerButtons = {};
      towerDefs.forEach(def => {
        const btn = document.createElement("button");
        btn.className = "tower-btn";
        btn.dataset.key = def.key;

        const title = document.createElement("div");
        title.className = "tower-btn-title";

        const nameSpan = document.createElement("span");
        nameSpan.className = "tower-btn-name";
        nameSpan.textContent = def.name;

        const costSpan = document.createElement("span");
        costSpan.className = "tower-btn-cost";
        costSpan.textContent = `${def.cost} ðŸª™`;

        title.appendChild(nameSpan);
        title.appendChild(costSpan);

        const desc = document.createElement("div");
        desc.className = "tower-btn-desc";
        if (def.key === "basic") desc.textContent = "Your starter tower. Balanced.";
        else if (def.key === "sniper") desc.textContent = "Huge range, slow but heavy hits.";
        else if (def.key === "splash") desc.textContent = "Explodes on impact, hitting groups.";
        else if (def.key === "frost") desc.textContent = "Slows enemies in its range.";
        else if (def.key === "laser") desc.textContent = "Continuous beam that melts armor.";
        else if (def.key === "poison") desc.textContent = "Applies damage over time.";
        else if (def.key === "support") {
          desc.textContent = "Buffs nearby towers' range & fire rate.";
          const tag = document.createElement("span");
          tag.className = "tag support";
          tag.textContent = "Support";
          nameSpan.appendChild(tag);
        }
        else if (def.key === "air") {
          desc.textContent = "Specialist vs flying enemies.";
          const tag = document.createElement("span");
          tag.className = "tag air";
          tag.textContent = "Anti-air";
          nameSpan.appendChild(tag);
        }

        btn.appendChild(title);
        btn.appendChild(desc);

        btn.addEventListener("click", () => {
          if (buildMode === def.key) {
            setBuildMode(null);
          } else {
            setBuildMode(def.key);
          }
        });

        towerButtonsContainer.appendChild(btn);
        towerButtons[def.key] = btn;
      });

      // Helper
      function dist(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // Wave & enemy spawning

      function setWaveUI() {
        waveEl.textContent = waveNumber;
        livesEl.textContent = lives;
        goldEl.textContent = gold;
        enemiesCountEl.textContent = enemies.length;
      }

      function getWaveScaling() {
        // Mixed arms + exponential-ish scaling
        const n = waveNumber;
        const hpMult = 1 + (n - 1) * 0.12;
        const speedMult = 1 + (n - 1) * 0.04;
        return { hpMult, speedMult };
      }

      function chooseEnemyTypeForWave() {
        const n = waveNumber;
        const types = [];

        if (n <= 3) types.push("grunt");
        else if (n <= 5) types.push("grunt", "fast");
        else if (n <= 7) types.push("grunt", "fast", "tank");
        else if (n <= 9) types.push("grunt", "fast", "tank", "shielded");
        else if (n <= 11) types.push("grunt", "fast", "tank", "shielded", "flyer");
        else types.push("grunt", "fast", "tank", "shielded", "flyer", "healer");

        // Weighted choice (fast & grunt more common)
        const pool = [];
        types.forEach(t => {
          if (t === "grunt") pool.push(t, t, t);
          else if (t === "fast") pool.push(t, t);
          else pool.push(t);
        });

        return pool[Math.floor(Math.random() * pool.length)];
      }

      function startWave() {
        if (waveInProgress) return;
        if (lives <= 0) return;
        waveInProgress = true;
        startWaveBtn.disabled = true;
        startWaveBtn.textContent = "Wave running...";

        const baseCount = 8 + waveNumber * 2;
        enemiesToSpawn = baseCount;

        // Boss every 5 waves
        if (waveNumber % 5 === 0) {
          enemiesToSpawn += 1; // boss on top
        }

        spawnTimer = 0.5;
      }

      function spawnEnemy() {
        if (enemiesToSpawn <= 0) return;
        enemiesToSpawn--;

        const { hpMult, speedMult } = getWaveScaling();

        let typeKey;
        // If it's a boss slot (simple: when enemiesToSpawn == 0 on boss waves)
        if (waveNumber % 5 === 0 && enemiesToSpawn === 0) {
          typeKey = "boss";
        } else {
          typeKey = chooseEnemyTypeForWave();
        }

        const base = enemyBaseTypes[typeKey];
        const pathIndex = base.flying
          ? Math.floor(Math.random() * paths.length) // we still reuse a path for start pos
          : Math.floor(Math.random() * paths.length);

        const path = paths[pathIndex];
        const start = path[0];

        const hpScale = base.boss ? hpMult * (1 + waveNumber * 0.4) : hpMult;
        const enemy = {
          typeKey,
          base,
          x: start.x,
          y: start.y,
          pathIndex,
          pathSegment: 0,
          hp: base.baseHp * hpScale,
          maxHp: base.baseHp * hpScale,
          reward: base.reward,
          baseSpeed: base.baseSpeed,
          speedMult,
          slowFactor: 1,
          slowTimer: 0,
          dotTimer: 0,
          dotDamage: 0,
          healCooldown: base.healer ? 2.5 : 0,
          reachedEnd: false
        };

        enemies.push(enemy);
      }

      function endWaveIfDone() {
        if (
          waveInProgress &&
          enemiesToSpawn === 0 &&
          enemies.length === 0
        ) {
          waveInProgress = false;
          waveNumber++;
          startWaveBtn.disabled = false;
          startWaveBtn.textContent = "Start Next Wave";
        }
      }

      // Tower build / selection UI

      function setBuildMode(key) {
        buildMode = key;
        Object.values(towerButtons).forEach(btn => {
          btn.classList.toggle("active", btn.dataset.key === key);
        });

        if (!key) {
          buildStatusText.textContent =
            "Select a tower type, then click on the map to place it.";
        } else {
          const def = towerDefs.find(d => d.key === key);
          buildStatusText.textContent =
            `Building ${def.name}. Click on the map to place (cost ${def.cost}).`;
        }
      }

      function getUpgradeCost(tower) {
        return 50 + tower.level * 50;
      }

      function upgradeTower(tower) {
        const cost = getUpgradeCost(tower);
        if (gold < cost) return false;
        gold -= cost;
        goldEl.textContent = gold;
        tower.level++;
        tower.damage = Math.round(tower.baseDamage * (1 + 0.35 * (tower.level - 1)));
        tower.range = Math.round(tower.baseRange * (1 + 0.2 * (tower.level - 1)));
        if (tower.baseFireRate > 0) {
          tower.fireRate = tower.baseFireRate * (1 + 0.3 * (tower.level - 1));
        }
        tower.supportPower = tower.level; // for support towers
        return true;
      }

      function updateTowerInfo() {
        if (!selectedTower) {
          towerInfoEl.innerHTML =
            '<div class="no-selection">No tower selected. Click a tower on the map.</div>';
          upgradeTowerBtn.disabled = true;
          return;
        }

        const t = selectedTower;
        const cost = getUpgradeCost(t);
        let extra = "";
        if (t.type === "splash") extra = " (Splash AOE)";
        else if (t.type === "slow") extra = " (Slows enemies)";
        else if (t.type === "laser") extra = " (Continuous beam)";
        else if (t.type === "poison") extra = " (Applies poison)";
        else if (t.type === "support") extra = " (Buff tower)";
        else if (t.key === "air") extra = " (Anti-air)";

        towerInfoEl.innerHTML = `
          <div class="tower-info-row"><strong>${t.name}</strong> (Lv. ${t.level})${extra}</div>
          <div class="tower-info-row">Damage: ${t.damage}${t.type === "laser" ? "/s" : ""}</div>
          <div class="tower-info-row">Range: ${t.range}</div>
          <div class="tower-info-row">Fire rate: ${
            t.fireRate ? t.fireRate.toFixed(2) + "/s" : "Special"
          }</div>
          <div class="tower-info-row">Next upgrade: 
            <span style="color:#facc15">${cost} gold</span>
          </div>
        `;
        upgradeTowerBtn.disabled = false;
      }

      upgradeTowerBtn.addEventListener("click", () => {
        if (!selectedTower) return;
        const ok = upgradeTower(selectedTower);
        if (!ok) {
          buildStatusText.textContent = "Not enough gold to upgrade.";
        } else {
          buildStatusText.textContent = "Tower upgraded!";
          updateTowerInfo();
        }
      });

      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * WIDTH;
        const y = ((e.clientY - rect.top) / rect.height) * HEIGHT;

        // Did we click a tower?
        let clickedTower = null;
        let bestDist = Infinity;
        towers.forEach(t => {
          const d = dist(x, y, t.x, t.y);
          if (d < 16 && d < bestDist) {
            bestDist = d;
            clickedTower = t;
          }
        });

        if (clickedTower) {
          selectedTower = clickedTower;
          setBuildMode(null);
          updateTowerInfo();
          return;
        }

        // If build mode: place tower
        if (buildMode) {
          const def = towerDefs.find(d => d.key === buildMode);
          if (gold < def.cost) {
            buildStatusText.textContent = "Not enough gold to build that tower.";
            return;
          }

          // Don't allow building too close to path center
          let okToPlace = true;
          paths.forEach(path => {
            for (let i = 0; i < path.length - 1; i++) {
              const p1 = path[i];
              const p2 = path[i + 1];
              const t = projectPointOnSegment(x, y, p1.x, p1.y, p2.x, p2.y);
              const d = dist(x, y, t.x, t.y);
              if (d < 24) {
                okToPlace = false;
                break;
              }
            }
          });

          if (!okToPlace) {
            buildStatusText.textContent = "Too close to the path. Try another spot.";
            return;
          }

          gold -= def.cost;
          goldEl.textContent = gold;

          const tower = createTower(def, x, y);
          towers.push(tower);
          selectedTower = tower;
          updateTowerInfo();
          buildStatusText.textContent = "Tower placed!";
        } else {
          // clicked empty ground, clear selection
          selectedTower = null;
          updateTowerInfo();
        }
      });

      function projectPointOnSegment(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lenSq = dx * dx + dy * dy || 1;
        let t = ((px - x1) * dx + (py - y1) * dy) / lenSq;
        t = Math.max(0, Math.min(1, t));
        return { x: x1 + t * dx, y: y1 + t * dy };
      }

      function createTower(def, x, y) {
        return {
          key: def.key,
          name: def.name,
          x, y,
          level: 1,
          baseDamage: def.baseDamage,
          baseRange: def.baseRange,
          baseFireRate: def.baseFireRate,
          bulletSpeed: def.bulletSpeed || 0,
          damage: def.baseDamage,
          range: def.baseRange,
          fireRate: def.baseFireRate,
          cooldown: 0,
          color: def.color,
          canHitAir: def.canHitAir,
          type: def.type,
          splashRadius: def.splashRadius || 0,
          slowAmount: def.slowAmount || 0,
          slowDuration: def.slowDuration || 0,
          dotDamage: def.dotDamage || 0,
          dotDuration: def.dotDuration || 0,
          supportPower: def.type === "support" ? 1 : 0
        };
      }

      // MAIN UPDATE

      function update(dt) {
        if (!running) return;

        // Spawn logic
        if (waveInProgress && enemiesToSpawn > 0) {
          spawnTimer -= dt;
          if (spawnTimer <= 0) {
            spawnEnemy();
            // Next spawn slightly faster later
            const baseInterval = 1.1;
            spawnTimer = Math.max(0.35, baseInterval - waveNumber * 0.03);
          }
        }

        // Update enemies
        enemies.forEach(e => {
          // DOT damage
          if (e.dotTimer > 0) {
            e.dotTimer -= dt;
            e.hp -= e.dotDamage * dt;
          }

          // Slow effect
          if (e.slowTimer > 0) {
            e.slowTimer -= dt;
            if (e.slowTimer <= 0) {
              e.slowFactor = 1;
            }
          }

          // Heal aura
          if (e.base.healer) {
            e.healCooldown -= dt;
            if (e.healCooldown <= 0) {
              e.healCooldown = 3;
              enemies.forEach(other => {
                if (other === e) return;
                if (dist(e.x, e.y, other.x, other.y) < 55) {
                  other.hp = Math.min(other.maxHp, other.hp + 12);
                }
              });
            }
          }

          // Movement
          const speed = e.base.baseSpeed * e.speedMult * e.slowFactor;
          if (e.base.flying) {
            // Flying takes a direct line from left to right across mid map
            const exitX = WIDTH + 30;
            const exitY = e.y; // horizontal line
            const dx = exitX - e.x;
            const dy = exitY - e.y;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            const vx = (dx / len) * speed;
            const vy = (dy / len) * speed;
            e.x += vx * dt;
            e.y += vy * dt;

            if (e.x > WIDTH + 25) {
              e.reachedEnd = true;
            }
          } else {
            const path = paths[e.pathIndex];
            const segIndex = e.pathSegment;
            const targetIndex = segIndex + 1;
            if (targetIndex >= path.length) {
              e.reachedEnd = true;
            } else {
              const from = path[segIndex];
              const to = path[targetIndex];
              const dx = to.x - from.x;
              const dy = to.y - from.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const vx = (dx / len) * speed;
              const vy = (dy / len) * speed;
              const moveDist = speed * dt;
              const distToTarget = dist(e.x, e.y, to.x, to.y);

              if (moveDist >= distToTarget) {
                e.x = to.x;
                e.y = to.y;
                e.pathSegment++;
              } else {
                e.x += vx * dt;
                e.y += vy * dt;
              }
            }
          }
        });

        // Remove dead or escaped enemies
        const remainingEnemies = [];
        enemies.forEach(e => {
          if (e.reachedEnd) {
            lives--;
            livesEl.textContent = lives;
            if (lives <= 0) {
              running = false;
              startWaveBtn.disabled = true;
              startWaveBtn.textContent = "Game Over";
            }
          } else if (e.hp <= 0) {
            gold += e.reward;
            goldEl.textContent = gold;
          } else {
            remainingEnemies.push(e);
          }
        });
        enemies = remainingEnemies;

        // Towers behavior

        // Support buffs
        const supportTowers = towers.filter(t => t.type === "support");
        towers.forEach(t => {
          t.effectiveRange = t.range;
          t.effectiveFireRate = t.fireRate;
        });
        supportTowers.forEach(sup => {
          towers.forEach(t => {
            if (t === sup) return;
            const d = dist(sup.x, sup.y, t.x, t.y);
            if (d <= sup.range) {
              const buff = 1 + 0.1 * sup.supportPower;
              t.effectiveRange = t.range * buff;
              if (t.fireRate > 0) {
                t.effectiveFireRate = t.fireRate * buff;
              }
            }
          });
        });

        // Towers shooting
        towers.forEach(t => {
          if (t.type === "support") return; // no direct attack

          if (t.type === "laser") {
            // Laser: continuous damage to single target
            const target = findTargetEnemy(t, true);
            if (target) {
              const dmgPerSecond = t.damage;
              target.hp -= dmgPerSecond * dt * (target.base.shielded ? 0.75 : 1.0);
              t.laserTarget = target;
            } else {
              t.laserTarget = null;
            }
          } else {
            t.cooldown -= dt;
            if (t.cooldown <= 0) {
              const target = findTargetEnemy(t, false);
              if (target) {
                fireTower(t, target);
                const fireRate = t.effectiveFireRate || t.fireRate || 1;
                t.cooldown = 1 / fireRate;
              } else {
                t.cooldown = Math.min(t.cooldown, 0.15);
              }
            }
          }
        });

        // Bullets
        const remainingBullets2 = [];
        bullets.forEach(b => {
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.life -= dt;
          if (b.life <= 0) return;

          // Hit detection
          let hit = false;
          for (const e of enemies) {
            if (b.towerType === "air" || b.towerKey === "air") {
              if (!e.base.flying) continue;
            }
            const d = dist(b.x, b.y, e.x, e.y);
            if (d < e.base.radius + b.radius + 1) {
              applyBulletHit(b, e);
              hit = true;
              break;
            }
          }
          if (!hit) {
            remainingBullets2.push(b);
          }
        });
        bullets = remainingBullets2;

        enemiesCountEl.textContent = enemies.length;
        endWaveIfDone();
      }

      function findTargetEnemy(tower, laser) {
        let bestEnemy = null;
        let bestScore = -Infinity;
        enemies.forEach(e => {
          if (e.base.flying && !tower.canHitAir) return;
          if (!e.base.flying && tower.key === "air") return; // anti-air can't hit ground
          const d = dist(tower.x, tower.y, e.x, e.y);
          const range = tower.effectiveRange ?? tower.range;
          if (d <= range) {
            // Priority: furthest along path
            const score = (e.pathSegment || 0) + (e.base.flying ? 1.5 : 0) + d * -0.01;
            if (score > bestScore) {
              bestScore = score;
              bestEnemy = e;
            }
          }
        });
        return bestEnemy;
      }

      function fireTower(tower, target) {
        if (tower.type === "splash" || tower.type === "poison" || tower.type === "slow" || tower.type === "projectile" || tower.key === "air") {
          const angle = Math.atan2(target.y - tower.y, target.x - tower.x);
          const speed = tower.bulletSpeed || 240;
          bullets.push({
            x: tower.x,
            y: tower.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            damage: tower.damage,
            radius: 3,
            life: 2,
            towerType: tower.type,
            towerKey: tower.key,
            splashRadius: tower.splashRadius,
            slowAmount: tower.slowAmount,
            slowDuration: tower.slowDuration,
            dotDamage: tower.dotDamage,
            dotDuration: tower.dotDuration
          });
        }
      }

      function applyBulletHit(b, enemy) {
        if (b.towerType === "splash") {
          enemies.forEach(e => {
            if (e.base.flying) return;
            if (dist(e.x, e.y, enemy.x, enemy.y) <= b.splashRadius) {
              let dmg = b.damage;
              if (e.base.shielded) dmg *= 0.75;
              e.hp -= dmg;
            }
          });
        } else if (b.towerType === "slow") {
          let dmg = b.damage;
          if (enemy.base.shielded) dmg *= 0.9;
          enemy.hp -= dmg;
          enemy.slowFactor = 1 - b.slowAmount;
          enemy.slowTimer = Math.max(enemy.slowTimer, b.slowDuration);
        } else if (b.towerType === "poison") {
          let dmg = b.damage;
          if (enemy.base.shielded) dmg *= 0.9;
          enemy.hp -= dmg;
          enemy.dotDamage = b.dotDamage;
          enemy.dotTimer = Math.max(enemy.dotTimer, b.dotDuration);
        } else {
          // normal projectile
          let dmg = b.damage;
          if (enemy.base.shielded) dmg *= 0.8;
          enemy.hp -= dmg;
        }
      }

      // DRAW

      function draw() {
        // Background
        ctx.fillStyle = "#1e293b";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // Light cartoon sky
        ctx.fillStyle = "#93c5fd";
        ctx.fillRect(0, 0, WIDTH, 80);

        // Cute sun
        ctx.fillStyle = "#facc15";
        ctx.beginPath();
        ctx.arc(40, 40, 14, 0, Math.PI * 2);
        ctx.fill();

        // Ground
        ctx.fillStyle = "#065f46";
        ctx.fillRect(0, 70, WIDTH, HEIGHT - 70);

        // Paths (three)
        paths.forEach((path, idx) => {
          // Path underlay
          ctx.strokeStyle = ["#fcd34d", "#fb923c", "#f97316"][idx] || "#fbbf24";
          ctx.lineWidth = 26;
          ctx.lineCap = "round";
          ctx.beginPath();
          path.forEach((p, i) => {
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          });
          ctx.stroke();

          // Inner darker
          ctx.strokeStyle = "#78350f";
          ctx.lineWidth = 6;
          ctx.beginPath();
          path.forEach((p, i) => {
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          });
          ctx.stroke();
        });

        // Grid light
        ctx.strokeStyle = "rgba(148,163,184,0.25)";
        ctx.lineWidth = 1;
        const g = 32;
        for (let x = 0; x <= WIDTH; x += g) {
          ctx.beginPath();
          ctx.moveTo(x, 80);
          ctx.lineTo(x, HEIGHT);
          ctx.stroke();
        }
        for (let y = 80; y <= HEIGHT; y += g) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(WIDTH, y);
          ctx.stroke();
        }

        // Towers
        towers.forEach(t => {
          ctx.save();
          ctx.translate(t.x, t.y);

          // Range if selected
          if (t === selectedTower) {
            ctx.fillStyle = "rgba(56,189,248,0.12)";
            ctx.beginPath();
            ctx.arc(0, 0, t.effectiveRange ?? t.range, 0, Math.PI * 2);
            ctx.fill();
          }

          // Base
          ctx.fillStyle = "#111827";
          ctx.beginPath();
          ctx.arc(0, 0, 14, 0, Math.PI * 2);
          ctx.fill();

          // Body
          ctx.fillStyle = t.color;
          ctx.beginPath();
          ctx.arc(0, -2, 10, 0, Math.PI * 2);
          ctx.fill();

          // Barrel / top
          if (t.type === "laser") {
            ctx.fillStyle = "#a855f7";
            ctx.fillRect(-3, -14, 6, 10);
          } else if (t.type === "support") {
            ctx.fillStyle = "#facc15";
            ctx.fillRect(-4, -12, 8, 8);
          } else {
            ctx.fillStyle = "#e5e7eb";
            ctx.fillRect(-3, -14, 6, 10);
          }

          // Selection ring
          if (t === selectedTower) {
            ctx.strokeStyle = "#38bdf8";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 16, 0, Math.PI * 2);
            ctx.stroke();
          }

          ctx.restore();
        });

        // Bullets
        bullets.forEach(b => {
          if (b.towerType === "poison") ctx.fillStyle = "#22c55e";
          else if (b.towerType === "slow") ctx.fillStyle = "#60a5fa";
          else if (b.towerType === "splash") ctx.fillStyle = "#f97316";
          else ctx.fillStyle = "#e5e7eb";
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        // Laser beams
        towers
          .filter(t => t.type === "laser" && t.laserTarget)
          .forEach(t => {
            const e = t.laserTarget;
            ctx.strokeStyle = "#a855f7";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(t.x, t.y - 8);
            ctx.lineTo(e.x, e.y);
            ctx.stroke();
          });

        // Enemies
        enemies.forEach(e => {
          ctx.save();
          ctx.translate(e.x, e.y);

          // Body
          ctx.fillStyle = e.base.color;
          ctx.beginPath();
          ctx.arc(0, 0, e.base.radius, 0, Math.PI * 2);
          ctx.fill();

          // Face/cartoon eyes
          ctx.fillStyle = "#0f172a";
          ctx.beginPath();
          ctx.arc(-3, -3, 2, 0, Math.PI * 2);
          ctx.arc(3, -3, 2, 0, Math.PI * 2);
          ctx.fill();

          // Flying shadow
          if (e.base.flying) {
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.ellipse(0, 8, e.base.radius + 3, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }

          // HP bar
          const w = e.base.radius * 2 + 8;
          const ratio = Math.max(0, e.hp / e.maxHp);
          ctx.fillStyle = "#0f172a";
          ctx.fillRect(-w / 2, -e.base.radius - 8, w, 4);
          ctx.fillStyle = ratio > 0.5 ? "#22c55e" : "#f97316";
          ctx.fillRect(-w / 2, -e.base.radius - 8, w * ratio, 4);

          // Status icons
          let offsetX = -w / 2;
          if (e.base.shielded) {
            ctx.fillStyle = "#60a5fa";
            ctx.fillRect(offsetX, -e.base.radius - 15, 5, 5);
            offsetX += 7;
          }
          if (e.base.healer) {
            ctx.fillStyle = "#facc15";
            ctx.fillRect(offsetX, -e.base.radius - 15, 5, 5);
            offsetX += 7;
          }
          if (e.base.boss) {
            ctx.fillStyle = "#ef4444";
            ctx.fillRect(offsetX, -e.base.radius - 15, 5, 5);
          }

          ctx.restore();
        });

        // Overlays
        if (!running) {
          ctx.fillStyle = "rgba(15,23,42,0.88)";
          ctx.fillRect(0, HEIGHT / 2 - 50, WIDTH, 100);
          ctx.fillStyle = "#e5e7eb";
          ctx.font = "26px system-ui";
          ctx.fillText("Game Over", WIDTH / 2 - 75, HEIGHT / 2 - 8);
          ctx.font = "15px system-ui";
          ctx.fillText("Refresh the page to restart.", WIDTH / 2 - 105, HEIGHT / 2 + 20);
        } else if (!waveInProgress && enemiesToSpawn === 0 && enemies.length === 0) {
          ctx.fillStyle = "rgba(15,23,42,0.75)";
          ctx.fillRect(0, HEIGHT / 2 - 45, WIDTH, 90);
          ctx.fillStyle = "#e5e7eb";
          ctx.font = "20px system-ui";
          ctx.fillText("Build your defenses!", WIDTH / 2 - 90, HEIGHT / 2 - 6);
          ctx.font = "14px system-ui";
          ctx.fillText("Click 'Start Wave' when ready.", WIDTH / 2 - 105, HEIGHT / 2 + 16);
        }
      }

      // MAIN LOOP

      function loop(timestamp) {
        const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
        lastTime = timestamp;
        update(dt);
        draw();
        if (running) requestAnimationFrame(loop);
      }

      // Start wave button
      startWaveBtn.addEventListener("click", startWave);

      // Pause on tab hidden
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          running = false;
        } else {
          if (lives > 0) {
            running = true;
            lastTime = performance.now();
            requestAnimationFrame(loop);
          }
        }
      });

      // INIT
      setWaveUI();
      updateTowerInfo();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
